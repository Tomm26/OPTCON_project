
# Flexible Robotic Arm Task1: from a desired quasi-step state-input curve (that evolves from one equilibrium to
# another) to an optimal trajectory thanks to the regularized Newton's Like Method (in its closed-loop version).

from parameters import ns, ni
from numpy import pi, array, column_stack, eye, diag
from equilibria import searchFRAInputGivenAnEquilibria
from curves import generateCurves, CurveType
from dynamics import discretizedDynamicFRA
from solver import runNewtonMethodTrkTrj
from miscellaneous import loadDataFromFile, saveDataOnFile
import logger

taskName = "task1"
def task1(lazyExecution = False):

    if lazyExecution:
        data = loadDataFromFile(taskName)
        if data is not None:
            logger.log("Task1 data loaded from file")
            return data

    # Definition of the time instants in which the desired input-state curve will evolve.
    T = array([0, 5, 11, 16])

    # Defining the desired input-state curve (an exponential-junction between two symmetric equilibrium points).
    # Notice: the input curve is generated by considering the angle of the first link of the FRA (at each
    # time instant) and by searching the corresponding input value that leads to the equilibrium in which
    # the second link is pointing downwards (alias at the same angle but with opposite sign).
    logger.log("Generating desired input-state curve (exponential-junction between two symmetric equilibrium points)...")
    swingingAngle = 120 # value in degrees
    angle = pi/180*swingingAngle/2
    xx_equilibrium1 = array([angle,-angle,0,0])
    xx_equilibrium2 = array([-angle,angle,0,0])
    xx_des, t = generateCurves(
        column_stack((xx_equilibrium1, xx_equilibrium1, xx_equilibrium2, xx_equilibrium2)), None,
        T, CurveType.exponential
    )
    uu_des = array([searchFRAInputGivenAnEquilibria(xx_des[0,i]) for i in range(len(t))]).reshape(1, len(t))

    # Notice that in the case we want simple steps as desired curve we can simply use the following code:
    # xx_des[:,:int(tx.size/2)] = xx_equilibrium1.reshape(ns,1)
    # xx_des[:,int(tx.size/2):] = xx_equilibrium2.reshape(ns,1)
    # uu_des[:int(tu.size/2)] = uu_equlibrium1.reshape(ni,1)
    # uu_des[int(tu.size/2):] = uu_equlibrium2.reshape(ni,1)

    # Defining cost matrices (for a trajectory tracking optimization probl0.001em) and applying the Newton Method
    logger.log("Defining cost matrices and applying the Newton Method...")
    QQ = diag([12.0, 12.0, 12.0, 12.0])
    RR = 0.001*eye(ni)
    newtonMethodMaxIterations = 42
    tolerance = 1e-6
    trjTrkOCPData = runNewtonMethodTrkTrj(
        xx_des, uu_des, newtonMethodMaxIterations,
        discretizedDynamicFRA, tolerance,
        QQ, RR, None, None, generateNicePlots = False
    )

    logger.log("Saving results on file and returning them")
    saveDataOnFile(trjTrkOCPData, taskName)
    return trjTrkOCPData

if __name__ == "__main__": task1()