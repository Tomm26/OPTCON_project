
# Curves Generator for states and inputs (points connector)

from numpy import linspace, exp, zeros, squeeze, abs, var, mean, inf, repeat, ones, ndarray
from parameters import discretizationStep as dt
from scipy.optimize import fsolve, minimize
from scipy.interpolate import CubicSpline
from enum import Enum
import warnings

class CurveType(Enum): sigmoid = "sigmoid"; cubic = "cubic"; exponential = "exponential"

def generateCurves(xxValues, uuValues, ttValues, curveTypeValues):
    """
    Generation of curves for states and inputs.
    These curves are generated interpolating the given points (for states and inpt) at the given times.
    Each segment of the curve can be generated by using a sigmoid, a cubic spline or an exponential spline.
    Arguments:
    - xxValues: nsxp seqeunce of states values to interpolate (where p is the numberOfPoints)
    - uuValues: nixp seqeunce of inputs values to interpolate (if None, only the states curve is generated)
    - ttValues: 1xp sequence of times values (ttValues[i] and ttValues[i+1] are the time instants of the i-th segment, with i from 0 to p-1)
    - curveTypeValues: 1x(p-1) sequence of spline types to use for each segment
                        (this value can also be passed as a scalar; in this case the same provided spline type is used for all the segments)
    Returns:
    - xx: nsxTT sequence of states values (where TT is the number of time steps and is computed as int(ttValues[-1]/dt))
    - uu: nixTT sequence of inputs values
    - t: 1xTT sequence of time values
    """
    
    TT = int(ttValues[-1]/dt) # number of time steps (each one of duration dt, enough for evolve from t=0 to t=T)
    t = squeeze(linspace(0, ttValues[-1], TT))
    ns = xxValues.shape[0]
    numberOfPoints = xxValues.shape[1]
    if not isinstance(curveTypeValues, ndarray): curveTypeValues = repeat(curveTypeValues, numberOfPoints-1).squeeze()
    xx = zeros((ns, TT))
    if uuValues is not None:
        ni = uuValues.shape[0]
        uu = zeros((ni, TT))

    for ii in range(numberOfPoints-1):
        # Generating the exponential spline trajectory bewtween the two points given by index ii and ii+1
        firstTimeIstant = int(ttValues[ii]/dt)
        secondTimeIstant = int(ttValues[ii+1]/dt)
        splineType = curveTypeValues[ii]
        for iis in range(ns):
            # Generating the esponential spline trajectory for the iis-th state
            if (xxValues[iis, ii] == xxValues[iis, ii+1]):
                xx[iis, firstTimeIstant:secondTimeIstant] = xxValues[iis, ii]*ones(secondTimeIstant-firstTimeIstant)
            elif splineType == CurveType.exponential:
                xx[iis, firstTimeIstant:secondTimeIstant] = exponentialSpline(ttValues[ii], ttValues[ii+1], xxValues[iis, ii], xxValues[iis, ii+1], dt)[0]
            elif splineType == CurveType.cubic:
                xx[iis, firstTimeIstant:secondTimeIstant] = cubicSpline(ttValues[ii], ttValues[ii+1], xxValues[iis, ii], xxValues[iis, ii+1], dt)[0]
            else:
                xx[iis, firstTimeIstant:secondTimeIstant] = sigmoid(ttValues[ii], ttValues[ii+1], xxValues[iis, ii], xxValues[iis, ii+1], dt)[0]
        if uuValues is None: continue
        for iii in range(ni):
            # Generating the esponential spline trajectory for the iii-th input
            if (uuValues[iii, ii] == uuValues[iii, ii+1]):
                uu[iii, firstTimeIstant:secondTimeIstant] = uuValues[iii, ii]*ones(secondTimeIstant-firstTimeIstant)
            elif splineType == CurveType.exponential:
                uu[iii, firstTimeIstant:secondTimeIstant] = exponentialSpline(ttValues[ii], ttValues[ii+1], uuValues[iii, ii], uuValues[iii, ii+1], dt)[0]
            elif splineType == CurveType.cubic:
                uu[iii, firstTimeIstant:secondTimeIstant] = cubicSpline(ttValues[ii], ttValues[ii+1], uuValues[iii, ii], uuValues[iii, ii+1], dt)[0]
            else:
                uu[iii, firstTimeIstant:secondTimeIstant] = sigmoid(ttValues[ii], ttValues[ii+1], uuValues[iii, ii], uuValues[iii, ii+1], dt)[0]

    if uuValues is None: return xx, t
    return xx, uu, t

def sigmoid(t1, t2, v1, v2, dt):
    """
    Generation of a sigmoid curve (by using the logistic function) between two constant points.
    Arguments:
    - t1: scalar initial time instant
    - t2: scalar final time instant
    - v1: scalar initial value
    - v2: scalar final value
    - dt: scalar time step
    """
    T = t2-t1; TT = int(T/dt); tVals = linspace(t1, t2, TT)
    error = 1; tolerance = 1e-4; k = 0.5
    while error > tolerance:
        error = 1/(1+exp(-k*(-T/2)))
        k = k + 0.01
    f = lambda t: 1/(1 + exp(-k*t))
    return  (v2-v1)*f(linspace(-T/2, T/2, TT))+v1, tVals

def exponentialSpline(t1, t2, v1, v2, dt):
    """
    Generation of an esponential spline curve between two constant points.
    The curve is generated by minimizing the variance of the curvature (normalized w.r.t its mean value) of the curve itself.
    Arguments:
    - t1: scalar initial time instant
    - t2: scalar final time instant
    - v1: scalar initial value
    - v2: scalar final value
    - dt: scalar time step
    """
    TT = int((t2-t1)/dt)
    tVals = linspace(t1, t2, TT)
    def solveExponentialSpline(k):
        def equations(vars):
            A, B, C, D = vars
            eq1 = A*exp(k*t1)+B*exp(-k*t1)+C*t1+D-v1
            eq2 = A*exp(k*t2)+B*exp(-k*t2)+C*t2+D-v2
            eq3 = A*k*exp(k*t1)-B*k*exp(-k*t1)+C
            eq4 = A*k*exp(k*t2)-B*k*exp(-k*t2)+C
            return squeeze([eq1, eq2, eq3, eq4])
        return fsolve(equations, [1, 1, 1, 1])
    def exponentialSplineFunctions(k, A, B, C, D):
        f = lambda t: A*exp(k*t)+B*exp(-k*t)+C*t+D
        dfdt = lambda t: A*k*exp(k*t)-B*k*exp(-k*t)+C
        d2fd2t = lambda t: A*(k**2)*exp(k*t)+B*(k**2)*exp(-k*t)
        return f, dfdt, d2fd2t
    def curvature(dfdt, d2fd2t):
        return abs(d2fd2t(tVals))/(1+dfdt(tVals)**2)**(3/2)
    def curvatureVariance(k):
        if k <= 0: return inf
        A, B, C, D = solveExponentialSpline(k)
        _, dfdt, d2fd2t = exponentialSplineFunctions(k, A, B, C, D)
        kValues = curvature(dfdt, d2fd2t)
        return var(kValues) / mean(kValues)
    
    warnings.filterwarnings("ignore")
    kk = minimize(curvatureVariance, x0=1.0, bounds=[(0.05, 4.0)], method='L-BFGS-B').x[0]
    A, B, C, D = solveExponentialSpline(kk)
    f, _, _ = exponentialSplineFunctions(kk, A, B, C, D)
    warnings.filterwarnings("default")

    return f(tVals), tVals

def cubicSpline(t1, t2, v1, v2, dt):
    """
    Generation of a cubic spline curve between two constant points.
    Arguments:
    - t1: scalar initial time instant
    - t2: scalar final time instant
    - v1: scalar initial value
    - v2: scalar final value
    - dt: scalar time step
    """
    TT = int((t2-t1)/dt)
    tVals = linspace(t1, t2, TT)
    f = CubicSpline([t1, t2], [v1, v2], bc_type=((1, 0.0), (1, 0.0)))
    return f(tVals), tVals