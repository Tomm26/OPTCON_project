
# Flexible Robotic Arm Task2: from a desired smooth state-input curve (that evolves from one equilibrium to
# another) to an optimal trajectory thanks to the regularized Newton's Like Method (in its closed-loop version).

from parameters import ni
from numpy import pi, array, column_stack, eye, diag
from equilibria import searchFRAInputGivenAnEquilibria
from curves import generateCurves, CurveType
from dynamics import discretizedDynamicFRA
from solver import runNewtonMethodTrkTrj
from miscellaneous import saveDataOnFile, loadDataFromFile
import logger

taskName = "task2"
def task2(lazyExecution = False):

    if lazyExecution:
        data = loadDataFromFile(taskName)
        if data is not None:
            logger.log("Task2 data loaded from file")
            return data

    # Definition of the time instants in which the desired input-state curve will evolve.
    T = array([0, 5, 9, 13, 17, 21, 26])
    # T = array([0, 4, 8, 12, 16, 20, 26])

    # Defining the desired input-state curve (a series of exponential-spline-junctions between a set of equilibrium points).
    # Notice: the input curve is generated by considering the angle of the first link of the FRA (at each
    # time instant) and by searching the corresponding input value that leads to the equilibrium in which
    # the second link is pointing downwards (alias at the same angle but with opposite sign).
    logger.log("Generating desired input-state smooth curve...")
    angle1 = (pi/180)*60
    angle2 = (pi/180)*30
    angle3 = (pi/180)*45
    angle4 = (pi/180)*90
    xx_equilibrium1 = array([angle1,-angle1,0,0])
    xx_equilibrium2 = array([-angle2,angle2,0,0])
    xx_equilibrium3 = array([angle3,-angle3,0,0])
    xx_equilibrium4 = array([angle4,-angle4,0,0])
    xx_des, t = generateCurves(
        column_stack((
            xx_equilibrium1,
            xx_equilibrium1,
            xx_equilibrium2,
            xx_equilibrium3,
            xx_equilibrium4,
            xx_equilibrium1,
            xx_equilibrium1)), None,
        T, CurveType.exponential
    )
    uu_des = array([searchFRAInputGivenAnEquilibria(xx_des[0,i]) for i in range(len(t))]).reshape(1, len(t))

    # Defining cost matrices (for a trajectory tracking optimization problem) and applying the Newton Method
    logger.log("Defining cost matrices and applying the Newton Method...")
    QQ = diag([16.0,16.0,6.0,6.0])
    RR = 0.001*eye(ni)
    newtonMethodMaxIterations = 42
    tolerance = 1e-6
    trjTrkOCPData = runNewtonMethodTrkTrj(
        xx_des, uu_des, newtonMethodMaxIterations,
        discretizedDynamicFRA, tolerance,
        QQ, RR, None, None, generateNicePlots = False
    )

    logger.log("Saving results on file and returning them")
    saveDataOnFile([trjTrkOCPData, QQ, RR], taskName)
    return trjTrkOCPData, QQ, RR

if __name__ == "__main__": task2()